# 变量、作用域和内存问题

---

## 1. 基本类型和引用类型

|          | 基本类型                                                   | 引用类型                                                   |
| -------- | ---------------------------------------------------------- | ---------------------------------------------------------- |
| 概念     | 简单数据段                                                 | 可能由多个值构成的对象                                     |
| 数据类型 | Undefined, Null, Boolean, Number, String                   | Object                                                     |
| 赋值     | var name = 13                                              | var name = new Object()<br/>name.age = 13                  |
| 复制引用 | Var num2 = num1<br/>num1和num2相互独立，改变num1不影响num2 | var obj2 = obj1<br/>改变obj1会影响obj2，实际引用的相同对象 |



### 1.1. 传参

> function传参是按值传递

- #### 基本类型传参

  ```javascript
  // function中的num和传入的参数num指向的是同一个argument对象 - 局部变量
  function add (num) {
    num += 10
    return num
  }
  
  var count = 20
  var result = add(count)
  alert(count) // 20 - 原数值不产生变化
  alert(result) // 30 - 局部变量结果产生变化 - 故function传参为按值传递
  ```

- #### 按引用类型传参

  ```javascript
  // function中对象的传参，本质上也是按值传递，但由于对象本身的赋值是引用赋值
  // 故，function中的argument和传入的person指向了内存中同一个object，
  // 所以person.name会产生变化，但并不代表function传参中局部变量会影响全局变量
  function setName(obj) {
    obj.name="Elanie"
    obj = new object()
    obj.name = "Henry" // 仅为内部重写的obj会赋值为Henry,而不会影响外部传入的person.name，重写的obj在函数结束时自动销毁
  }
  
  var person = new Object()
  setName(person)
  alert(person.name) // "Elanie"
  ```

  

### 1.2 检测类型

> typeof并不能满足确认变量具体的对象的类型, 如：RegExp, Constructor等
>
> 例如：null和object的typeof值都是object，无法区分

- 判断具体类型 - instanceof - 返回true/false

  ```javascript
  var o = new Object()
  
  alert(o instanceof Array)
  alert(o instanceof Constructor)
  alert(o instanceof RegExp)
  ```

  

## 2. 执行环境及作用域

> 1. 执行环境 execution context：定义了变量或函数有权访问的其他数据，决定它们各自的行为
> 2. 变量对象 variable objext：每个环境中有一个，环境中定义的所有变量和函数都保存在这个对象中，解析器使用它进行解析
> 3. 全局执行环境：web浏览器中，是window对象，所有全局变量和函数都是作为window对象的属性和方法进行创建的
>    1. 每个函数都有自己的执行环境。
>    2. 执行流进入一个函数时，函数环境会被推入一个环境栈中，执行结束后，推出该环境，将控制权返回给之前的执行环境
>    3. 某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁
> 4. 作用域链 scope chain：代码在一个环境中执行，就会创建变量对象的一个作用域链 - （执行顺序问题）
>    1. 用途：保证对执行环境有权访问的所有变量和函数有序访问
>    2. 作用域链前端始终是当前执行的代码的对象在最开始时包含的变量对象；最后一个对象一定是全局执行环境变量对象；
>    3. 如果环境是一个function，则将其活动对象 activation object 作为变量对象。活动对象最开始只有arguments一个对象。